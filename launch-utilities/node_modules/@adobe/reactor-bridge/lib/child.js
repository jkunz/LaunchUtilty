/***************************************************************************************
 * (c) 2017 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

import Penpal from 'penpal';
import Promise from 'promise-polyfill';
import Logger from './utils/logger';
import addStylesToPage from './utils/addStylesToPage';

var STYLES = '\n  html, body {\n    background-color: transparent !important;\n  }\n';

addStylesToPage(STYLES);

Penpal.Promise = Promise;

var logger = new Logger('ExtensionBridge:Child');
var extensionViewMethods = {};
var connectionPromise = void 0;

var getExtensionViewMethod = function getExtensionViewMethod(methodName) {
  var method = extensionViewMethods[methodName];
  if (method) {
    return method.bind(extensionViewMethods);
  } else {
    throw new Error('Unable to call ' + methodName + ' on the extension. The extension must register a ' + methodName + ' function using extensionBridge.register().');
  }
};

var init = function init() {
  getExtensionViewMethod('init').apply(undefined, arguments);
};

var validate = function validate() {
  var result = getExtensionViewMethod('validate').apply(undefined, arguments);

  if (typeof result !== 'boolean') {
    throw new Error('The extension attempted to return a non-boolean value from validate: ' + result);
  }

  return result;
};

var getSettings = function getSettings() {
  var result = getExtensionViewMethod('getSettings').apply(undefined, arguments);

  if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) !== 'object') {
    throw new Error('The extension attempted to return a non-object value from getSettings: ' + result);
  }

  return result;
};

var wrapOpenSharedViewMethod = function wrapOpenSharedViewMethod(methodName, sharedViewName) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var callback = void 0;

    if (typeof args[0] === 'function') {
      callback = args.shift();
      // Deprecated April 10, 2018. 30+ extensions were using a callback at the time.
      console.warn('Passing a callback to extensionBridge.' + methodName + '() has been deprecated. ' + 'The method now returns a promise that should be used instead.');
    }

    return connectionPromise.then(function (parent) {
      if (parent[methodName]) {
        return parent[methodName].apply(parent, args);
      } else {
        throw new Error('An error occurred while opening ' + sharedViewName + '. The shared view is unavailable.');
      }
    }).then(function (result) {
      if (callback) {
        callback(result);
      }
      return result;
    });
  };
};

connectionPromise = Penpal.connectToParent({
  methods: {
    init: init,
    validate: validate,
    getSettings: getSettings
  }
}).promise;

var extensionBridge = {
  openCodeEditor: wrapOpenSharedViewMethod('openCodeEditor', 'code editor'),
  openDataElementSelector: wrapOpenSharedViewMethod('openDataElementSelector', 'data element selector'),
  openRegexTester: wrapOpenSharedViewMethod('openRegexTester', 'regex tester'),
  register: function register(methods) {
    extensionViewMethods = babelHelpers.extends({}, methods);
    connectionPromise.then(function (parent) {
      return parent.extensionRegistered();
    });
    logger.log('Methods registered by extension.');
  },
  setDebug: function setDebug(value) {
    Penpal.debug = value;
    Logger.enabled = value;
  }
};

window.addEventListener('focus', function () {
  connectionPromise.then(function (parent) {
    return parent.markAsDirty();
  });
});

var executeQueuedCall = function executeQueuedCall(call) {
  // Not all of the extension bridge methods return promises. Rather than do a switch where we
  // only handle promises coming from certain methods here, we'll just always convert the return
  // value to a promise and them consistently.
  Promise.resolve(extensionBridge[call.methodName].apply(extensionBridge, babelHelpers.toConsumableArray(call.args))).then(call.resolve, call.reject);
};

var callQueue = window.extensionBridge._callQueue;

while (callQueue.length) {
  executeQueuedCall(callQueue.shift());
}

callQueue.push = executeQueuedCall;